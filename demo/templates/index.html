<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async-Cache Test UI</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f4f4f4; }
        h1, h2 { color: #333; }
        .section { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        label { display: block; margin: 10px 0; }
        input[type=number], input[type=checkbox] { margin-left: 10px; }
        button { margin: 5px; padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .results { margin-top: 10px; padding: 10px; background: #e9ecef; border-radius: 3px; white-space: pre-wrap; }
        .collection-btn { background: #28a745; }
        .collection-btn:hover { background: #218838; }
        .clear-btn { background: #dc3545; }
        .clear-btn:hover { background: #c82333; }
        .warn { color: #856404; background: #fff3cd; padding: 10px; border-radius: 3px; }
        .mode-section { display: none; }
        .mode-section.active { display: block; }
        .tabs { margin: 10px 0; }
        .tab-btn { background: #6c757d; }
        .tab-btn.active { background: #007bff; }
        /* Toggleable param groups based on mode/batch */
        .param-group { display: block; }
        .param-group.hidden { display: none; }
    </style>
</head>
<body>
    <h1>Async-Cache Test UI</h1>
    <p class="warn">Simple, functional UI to configure and test async-cache features: TTL/LRU decorators, direct AsyncCache, thundering herd protection, batch loader, metrics, warmup, set/get/delete, use_cache, skip_args etc.</p>
    
    <!-- Config Section -->
    <div class="section">
        <h2>Cache Configuration</h2>
        <p class="warn">Params adapt to interface (e.g., batch_* for direct+batch-dataloader only, skip_args/use_cache for decorators only) + custom keys; 100ms DB sim on misses.</p>
        <label>Max Size: <input id="maxsize" type="number" value="128" min="1"></label>
        <label>TTL (seconds, empty for none): <input id="ttl" type="number" value="60" min="0" placeholder="60 or empty"></label>
        <!-- skip_args: decorators (@TTL/@LRU) only -->
        <div id="skip-params" class="param-group">
            <label>Skip Args (TTL+LRU keys; e.g. skip 'self'): <input id="skip_args" type="number" value="0" min="0"></label>
        </div>
        <!-- batch params: direct + batch-dataloader enabled only -->
        <div id="batch-params" class="param-group">
            <label>Batch Window (ms): <input id="batch_window_ms" type="number" value="5" min="1"></label>
            <label>Max Batch Size: <input id="max_batch_size" type="number" value="100" min="1"></label>
        </div>
        <label>Custom Keys (comma-sep, e.g. 'same-key' or 'unique:50' for N uniques; overrides collections/warmup): <input id="custom_keys" type="text" value="" placeholder="leave empty for defaults"></label>
        <button onclick="configureCache()">Apply Configuration</button>
        <button class="clear-btn" onclick="clearAllCaches()">Clear All Caches</button>
    </div>

    <!-- Tabs for Modes -->
    <div class="section">
        <h2>Cache Type</h2>
        <div class="tabs">
            <button class="tab-btn active" onclick="switchMode('ttl')">@AsyncTTL Decorator</button>
            <button class="tab-btn" onclick="switchMode('lru')">@AsyncLRU Decorator</button>
            <button class="tab-btn" onclick="switchMode('cache')">Direct AsyncCache</button>
        </div>
        <!-- use_cache flag: decorator-only (not for direct AsyncCache) -->
        <div id="use-cache-section">
            <label><input id="use_cache_default" type="checkbox" checked> Use Cache (force-miss=false; decorator-only param)</label>
        </div>
    </div>

    <!-- Progress bar for long tests (100 parallel requests) -->
    <div id="progress-section" class="section" style="display: none;">
        <h3>Running Test...</h3>
        <progress id="prog-bar" value="0" max="100" style="width: 100%;"></progress>
        <span id="prog-text">0% - Sending parallel requests...</span>
    </div>

    <!-- Test Collections - 5 collections for different features -->
    <div id="mode-ttl" class="section mode-section active">
        <h2>Test @AsyncTTL Decorator</h2>
        <p>Decorator-only: herd (single-loader), skip_args, TTL expiry, use_cache (force-miss flag below).</p>
        <div id="ttl-collections"></div>
    </div>

    <div id="mode-lru" class="section mode-section">
        <h2>Test @AsyncLRU Decorator</h2>
        <p>Decorator-only: herd, skip_args (now supported), LRU eviction, use_cache flag (no TTL).</p>
        <div id="lru-collections"></div>
    </div>

    <div id="mode-cache" class="section mode-section">
        <h2>Test Direct AsyncCache Class</h2>
        <p>Full features: batch dataloader (configurable), single-loader (herd prot), warmup, set/delete, metrics, etc.</p>
        <label><input id="use_batch" type="checkbox"> Use Batch Data Loader (for unique keys test; 1 DB call vs. 100)</label>
        <div id="cache-collections"></div>
        <hr>
        <h3>Additional Features</h3>
        <button onclick="testWarmup()">Warmup (preloads keys)</button>
        <button onclick="testSetGetDelete()">Test Set / Get / Delete</button>
    </div>

    <!-- Results -->
    <div class="section">
        <h2>Results & Metrics (Last Test Run Only)</h2>
        <p class="warn">Metrics ONLY from /metrics API. For all-miss cases (e.g., concurrent same/unique keys): misses=N is correct (cache semantics); herd/batch protects DB load (see timing: ~100ms vs. 10s for 100 misses). Custom keys override collections.</p>
        <div id="results" class="results">Run a test to see metrics (hit ratio, hits, misses) here...</div>
    </div>

    <script>
        // Mode-specific collections (decorators: single-loader/herd/use_cache/TTL/LRU; direct: batch vs single, warmup etc.)
        // Custom keys override via form (for any test e.g. warmup keys).
        // Note: 100ms mock DB sleep on misses; batch/herd ensures ~1 DB call (timing proves protection).
        // TTL/Lru: 4-5 unique tests; direct: 7 incl. batch variants.
        const modeCollections = {
            ttl: [
                {name: "1. All Same Key (Thundering Herd Prot.)", keys: Array(100).fill('ttl-same') },
                {name: "2. 100 Unique Keys (Herd + TTL expiry)", keys: Array.from({length: 100}, (_, i) => `ttl-unique-${i}`) },
                {name: "3. Mixed Keys (Herd mix)", keys: [...Array(50).fill('ttl-mixed'), ...Array.from({length: 50}, (_, i) => `ttl-mix-${i}`)] },
                {name: "4. Force Misses (use_cache=false x100)", keys: Array.from({length: 100}, (_, i) => `ttl-force-${i}`), force_miss: true },
                {name: "5. Repeat Keys (High hit ratio post-miss)", keys: Array(100).fill('ttl-repeat') }
            ],
            lru: [
                {name: "1. All Same Key (Herd Prot. - LRU eviction test)", keys: Array(100).fill('lru-same') },
                {name: "2. 100 Unique Keys (LRU maxsize test)", keys: Array.from({length: 100}, (_, i) => `lru-unique-${i}`) },
                {name: "3. Mixed Keys (Herd in LRU)", keys: [...Array(50).fill('lru-mixed'), ...Array.from({length: 50}, (_, i) => `lru-mix-${i}`)] },
                {name: "4. Force Misses (use_cache=false)", keys: Array.from({length: 100}, (_, i) => `lru-force-${i}`), force_miss: true },
                {name: "5. Repeat After Clear (Hit ratio reset)", keys: Array(100).fill('lru-repeat') }  // pair w/ clear for demo
            ],
            cache: [
                {name: "1. Same Key (Herd Prot.)", keys: Array(100).fill('cache-same') },
                {name: "2. 100 Unique (Batch Loader - 1 DB call)", keys: Array.from({length: 100}, (_, i) => `cache-unique-${i}`) },
                {name: "3. Mixed Keys (Batch + Herd)", keys: [...Array(50).fill('cache-mixed'), ...Array.from({length: 50}, (_, i) => `cache-mix-${i}`)] },
                {name: "4. Force Misses (direct get)", keys: Array.from({length: 100}, (_, i) => `cache-force-${i}`) },
                {name: "5. Repeat Keys (Hit ratio)", keys: Array(100).fill('cache-repeat') },
                {name: "6. Batch vs Single: Unique Keys (Batch on)", keys: Array.from({length: 50}, (_, i) => `cache-batch-${i}`) },
                {name: "7. Warmup Keys (Preload test)", keys: Array.from({length: 20}, (_, i) => `warm-${i}`) }
            ]
        };

        // Parse custom keys from UI (supports comma-sep, 'same-key', or 'unique:N' for N unique keys)
        // Used for any test incl. warmup (e.g., specify exact keys).
        function parseCustomKeys() {
            const input = document.getElementById('custom_keys').value.trim();
            if (!input) return null;  // fallback to collection defaults
            if (input.startsWith('unique:')) {
                const n = parseInt(input.split(':')[1]) || 100;
                return Array.from({length: n}, (_, i) => `unique-key-${i}`);
            }
            if (input.includes(',')) {
                return input.split(',').map(k => k.trim());
            }
            // e.g., single/same-key
            return Array(100).fill(input);  // default 100x same for herd etc.
        }

        // Create buttons for each collection per mode (unique per interface: decorators single/herd/use_cache, direct batch/single)
        function createCollectionButtons(containerId, mode) {
            const container = document.getElementById(containerId);
            modeCollections[mode].forEach((coll, idx) => {
                const btn = document.createElement('button');
                btn.className = 'collection-btn';
                btn.textContent = coll.name;
                btn.onclick = () => runCollectionTest(mode, idx);
                container.appendChild(btn);
                container.appendChild(document.createElement('br'));
            });
        }

        // Init buttons (mode-specific)
        createCollectionButtons('ttl-collections', 'ttl');
        createCollectionButtons('lru-collections', 'lru');
        createCollectionButtons('cache-collections', 'cache');

        // Tab switch + dynamic params for interface:
        // - skip_args/use_cache: decorators (@TTL/@LRU) only
        // - batch_window/max_batch: direct + batch-dataloader enabled only
        // - use_cache/batch checkboxes, collections unique per mode
        // - Progress bar for tests
        function switchMode(mode) {
            document.querySelectorAll('.mode-section').forEach(sec => sec.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');
            document.querySelector(`.tab-btn[onclick="switchMode('${mode}')"]`).classList.add('active');
            // Toggle mode-specific params
            updateParamsForMode(mode);
        }

        // Update visible params based on mode (+ batch flag for direct)
        function updateParamsForMode(mode) {
            const isDecorator = (mode === 'ttl' || mode === 'lru');
            const isDirect = (mode === 'cache');
            const useBatch = isDirect && document.getElementById('use_batch').checked;
            // use_cache: decorators only
            const useCacheSec = document.getElementById('use-cache-section');
            useCacheSec.style.display = isDecorator ? 'block' : 'none';
            // skip_args: decorators only
            document.getElementById('skip-params').classList.toggle('hidden', !isDecorator);
            // batch params: direct AND batch-dataloader enabled only
            document.getElementById('batch-params').classList.toggle('hidden', !useBatch);
            // re-configure on param change for direct batch toggle
            if (isDirect) {
                document.getElementById('use_batch').onchange = () => {
                    updateParamsForMode(mode);
                    configureCache();  // re-apply for batch_window etc.
                };
            }
        }

        // Show/hide+update progress bar for running tests (100 reqs)
        function showProgress(percent, text = '') {
            const progSec = document.getElementById('progress-section');
            const bar = document.getElementById('prog-bar');
            const txt = document.getElementById('prog-text');
            progSec.style.display = 'block';
            bar.value = percent;
            txt.textContent = `${percent}% - ${text}`;
        }

        function hideProgress() {
            document.getElementById('progress-section').style.display = 'none';
        }

        // Get config from form
        function getConfig() {
            return {
                maxsize: parseInt(document.getElementById('maxsize').value) || 128,
                ttl: document.getElementById('ttl').value ? parseInt(document.getElementById('ttl').value) : null,
                skip_args: parseInt(document.getElementById('skip_args').value) || 0,
                batch_window_ms: parseInt(document.getElementById('batch_window_ms').value) || 5,
                max_batch_size: parseInt(document.getElementById('max_batch_size').value) || 100
            };
        }

        // Configure cache (recreates with new params)
        async function configureCache() {
            const config = getConfig();
            const resp = await fetch('/configure', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(config)
            });
            const data = await resp.json();
            setResult(`Configured: ${JSON.stringify(data.config, null, 2)}`);
        }

        // Get keys for test: custom from UI if provided (for warmup etc.), else collection default
        function getKeysForTest(coll) {
            const custom = parseCustomKeys();
            if (custom) return custom;
            return coll.keys;
        }

        // Run 100 parallel requests for a collection (simulates concurrent load for herd/batch)
        // Mode-specific: decorators (use_cache/herd/single); direct (batch flag).
        // Supports custom keys; batch config; metrics ONLY from API; results show LAST test only.
        // Progress bar updates during run (config -> parallel reqs -> metrics).
        async function runCollectionTest(mode, collId) {
            showProgress(10, 'Configuring cache...');
            const coll = modeCollections[mode][collId];
            const keys = getKeysForTest(coll);  // custom override e.g. for warmup keys
            const useBatch = (mode === 'cache') && document.getElementById('use_batch').checked;
            const defaultUseCache = document.getElementById('use_cache_default').checked;
            const force_miss = coll.force_miss || false;
            await configureCache();  // ensure config
            showProgress(40, `Sending ${keys.length} parallel requests...`);
            const cacheType = mode === 'cache' ? 'direct' : mode;
            const startTime = performance.now();
            // Send requests IN PARALLEL using Promise.all + fetch (demo herd/batch under concurrency)
            // use_cache: decorator-only (@TTL/@LRU); direct always 'true' (no param)
            // Batch flag: direct-only; uses dataloader when enabled
            const requests = keys.map(key => {
                const body = {key};
                if (mode !== 'cache') {
                    // decorator-only
                    const use_cache = !force_miss && defaultUseCache;
                    body.use_cache = use_cache;
                }
                if (mode === 'cache') {
                    body.use_batch = useBatch;  // true= batch_loader
                }
                return fetch(`/call/${mode}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(body)
                }).then(r => r.json());
            });
            const results = await Promise.all(requests);
            showProgress(80, 'Fetching metrics...');
            const elapsed = (performance.now() - startTime).toFixed(2);
            // Get metrics after to show hit ratio, misses (ONLY from metrics API)
            const metricsResp = await fetch(`/metrics/${cacheType}`);
            const metrics = await metricsResp.json();
            const summary = `Test: ${coll.name} | Mode: ${mode}${useBatch ? '-batch' : ''} | Keys: ${keys.length} (custom: ${!!parseCustomKeys()}) | Time: ${elapsed}ms\n` +
                           `Metrics (from API): Hits=${metrics.hits}, Misses=${metrics.misses}, Hit Rate=${(metrics.hit_rate*100).toFixed(2)}%, Size=${metrics.size}\n` +
                           `Note: All-miss OK for concurrent/first-run (DB calls minimized by herd/batch: ~100ms vs. 10s)`;
            setResult(summary);
            console.log('Results sample:', results.slice(0, 5));  // log full if needed
            showProgress(100, 'Complete!');
            setTimeout(hideProgress, 1500);  // hide after brief
        }

        // Additional: Warmup test (uses custom keys if provided; shows progress)
        async function testWarmup() {
            showProgress(20, 'Configuring for warmup...');
            await configureCache();
            // Override with custom or default
            let keys = parseCustomKeys();
            if (!keys) {
                keys = Array.from({length: 20}, (_, i) => `warmup-key-${i}`);
            }
            showProgress(60, `Warming ${keys.length} keys...`);
            const resp = await fetch('/warmup/cache', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({keys})
            });
            const data = await resp.json();
            setResult(`Warmup: ${data.status} for ${data.keys.length} keys (custom: ${!!parseCustomKeys()}). Metrics (from API): ${JSON.stringify(data.metrics)}`);
            showProgress(100, 'Warmup complete!');
            setTimeout(hideProgress, 1500);
        }

        // Test set/get/delete (with progress)
        async function testSetGetDelete() {
            showProgress(30, 'Running set/get/delete...');
            await configureCache();
            // set
            await fetch('/set/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key', value: 'set-value', ttl: 30})});
            // get (should hit)
            const getResp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const getData = await getResp.json();
            // delete
            await fetch('/delete/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            // get again (miss)
            const get2Resp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const get2Data = await get2Resp.json();
            const metrics = await (await fetch('/metrics/direct')).json();
            setResult(`Set/Get/Delete Test: set='set-value', get1=${getData.result}, after-delete get2=${get2Data.result}\nMetrics (from API): ${JSON.stringify(metrics)}`);
            showProgress(100, 'Complete!');
            setTimeout(hideProgress, 1500);
        }

        // Clear all
        async function clearAllCaches() {
            showProgress(50, 'Clearing caches...');
            ['ttl', 'lru', 'direct'].forEach(async (t) => {
                await fetch(`/clear/${t}`, {method: 'POST'});
            });
            setResult('All caches cleared.');
            hideProgress();
        }

        // Set result (LAST test only, no append)
        function setResult(text) {
            const resDiv = document.getElementById('results');
            resDiv.textContent = '--- Last Run ---\n' + text;
            // auto scroll if needed
            resDiv.scrollTop = resDiv.scrollHeight;
        }

        // Initial config + param UI + defaults
        window.onload = () => {
            configureCache();
            // Default to TTL mode UI
            updateParamsForMode('ttl');
            setResult('UI loaded. Params adapt to mode (e.g., batch only for direct+batch-flag); progress bar for tests.');
        };
    </script>
</body>
</html>
