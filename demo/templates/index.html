<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async-Cache Test UI</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f4f4f4; }
        h1, h2 { color: #333; }
        .section { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        label { display: block; margin: 10px 0; }
        input[type=number], input[type=checkbox] { margin-left: 10px; }
        button { margin: 5px; padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .results { margin-top: 10px; padding: 10px; background: #e9ecef; border-radius: 3px; white-space: pre-wrap; }
        .collection-btn { background: #28a745; }
        .collection-btn:hover { background: #218838; }
        .clear-btn { background: #dc3545; }
        .clear-btn:hover { background: #c82333; }
        .warn { color: #856404; background: #fff3cd; padding: 10px; border-radius: 3px; }
        .mode-section { display: none; }
        .mode-section.active { display: block; }
        .tabs { margin: 10px 0; }
        .tab-btn { background: #6c757d; }
        .tab-btn.active { background: #007bff; }
    </style>
</head>
<body>
    <h1>Async-Cache Test UI</h1>
    <p class="warn">Simple, functional UI to configure and test async-cache features: TTL/LRU decorators, direct AsyncCache, thundering herd protection, batch loader, metrics, warmup, set/get/delete, use_cache, skip_args etc.</p>
    
    <!-- Config Section -->
    <div class="section">
        <h2>Cache Configuration</h2>
        <p class="warn">Configure params; batch dataloader (direct mode checkbox below); skip_args now works on LRU too; custom keys; 100ms mock DB sleep on misses.</p>
        <label>Max Size: <input id="maxsize" type="number" value="128" min="1"></label>
        <label>TTL (seconds, empty for none): <input id="ttl" type="number" value="60" min="0" placeholder="60 or empty"></label>
        <label>Skip Args (now for TTL+LRU keys): <input id="skip_args" type="number" value="0" min="0"></label>
        <label>Batch Window (ms): <input id="batch_window_ms" type="number" value="5" min="1"></label>
        <label>Max Batch Size: <input id="max_batch_size" type="number" value="100" min="1"></label>
        <label><input id="use_cache_default" type="checkbox" checked> Default Use Cache</label>
        <label>Custom Keys (comma-sep, e.g. 'same-key' or 'unique-1,unique-2' or 'unique:50' for N uniques): <input id="custom_keys" type="text" value="" placeholder="leave empty for collection defaults"></label>
        <button onclick="configureCache()">Apply Configuration</button>
        <button class="clear-btn" onclick="clearAllCaches()">Clear All Caches</button>
    </div>

    <!-- Tabs for Modes -->
    <div class="section">
        <h2>Cache Type</h2>
        <div class="tabs">
            <button class="tab-btn active" onclick="switchMode('ttl')">@AsyncTTL Decorator</button>
            <button class="tab-btn" onclick="switchMode('lru')">@AsyncLRU Decorator</button>
            <button class="tab-btn" onclick="switchMode('cache')">Direct AsyncCache</button>
        </div>
    </div>

    <!-- Test Collections - 5 collections for different features -->
    <div id="mode-ttl" class="section mode-section active">
        <h2>Test @AsyncTTL Decorator</h2>
        <p>Tests herd protection (same key), batch not direct here (single loader), skip_args, TTL expiry, use_cache=false.</p>
        <div id="ttl-collections"></div>
    </div>

    <div id="mode-lru" class="section mode-section">
        <h2>Test @AsyncLRU Decorator</h2>
        <p>Similar to TTL but no expiry/TTL. Good for hit/miss ratios.</p>
        <div id="lru-collections"></div>
    </div>

    <div id="mode-cache" class="section mode-section">
        <h2>Test Direct AsyncCache Class</h2>
        <p>Full features: batch dataloader (configurable), single-loader (herd prot), warmup, set/delete, metrics, etc.</p>
        <label><input id="use_batch" type="checkbox"> Use Batch Data Loader (for unique keys test; 1 DB call vs. 100)</label>
        <div id="cache-collections"></div>
        <hr>
        <h3>Additional Features</h3>
        <button onclick="testWarmup()">Warmup (preloads keys)</button>
        <button onclick="testSetGetDelete()">Test Set / Get / Delete</button>
    </div>

    <!-- Results -->
    <div class="section">
        <h2>Results & Metrics (Last Test Run Only)</h2>
        <p class="warn">Metrics ONLY from /metrics API. For all-miss cases (e.g., concurrent same/unique keys): misses=N is correct (cache semantics); herd/batch protects DB load (see timing: ~100ms vs. 10s for 100 misses). Custom keys override collections.</p>
        <div id="results" class="results">Run a test to see metrics (hit ratio, hits, misses) here...</div>
    </div>

    <script>
        // 5 collections of 100 requests with diff key combos to test features
        // Custom keys override via form (e.g., for warmup-specific keys).
        // Note: 100ms mock DB sleep on misses; batch/herd ensures ~1 DB call (timing proves protection).
        const collections = {
            1: {name: "1. All Same Key (Tests Thundering Herd Protection)", keys: Array(100).fill('same-key') },
            2: {name: "2. 100 Unique Keys (Tests Batch Data Loader)", keys: Array.from({length: 100}, (_, i) => `unique-key-${i}`) },
            3: {name: "3. Mixed Keys (50 same + 50 unique - mix herd + batch)", keys: [...Array(50).fill('mixed-key'), ...Array.from({length: 50}, (_, i) => `mix-${i}`)] },
            4: {name: "4. Force Misses (use_cache=false x100 - bypass cache)", keys: Array.from({length: 100}, (_, i) => `force-${i}`), force_miss: true },
            5: {name: "5. Repeat Keys After Load (Expect high hit ratio)", keys: Array(100).fill('repeat-key') }  // run after other to see hits
        };

        // Parse custom keys from UI (supports comma-sep, 'same-key', or 'unique:N' for N unique keys)
        // Used for any test incl. warmup (e.g., specify exact keys).
        function parseCustomKeys() {
            const input = document.getElementById('custom_keys').value.trim();
            if (!input) return null;  // fallback to collection defaults
            if (input.startsWith('unique:')) {
                const n = parseInt(input.split(':')[1]) || 100;
                return Array.from({length: n}, (_, i) => `unique-key-${i}`);
            }
            if (input.includes(',')) {
                return input.split(',').map(k => k.trim());
            }
            // e.g., single/same-key
            return Array(100).fill(input);  // default 100x same for herd etc.
        }

        // Create buttons for each collection per mode
        function createCollectionButtons(containerId, mode) {
            const container = document.getElementById(containerId);
            Object.keys(collections).forEach(id => {
                const coll = collections[id];
                const btn = document.createElement('button');
                btn.className = 'collection-btn';
                btn.textContent = coll.name;
                btn.onclick = () => runCollectionTest(mode, parseInt(id));
                container.appendChild(btn);
                container.appendChild(document.createElement('br'));
            });
        }

        // Init buttons
        createCollectionButtons('ttl-collections', 'ttl');
        createCollectionButtons('lru-collections', 'lru');
        createCollectionButtons('cache-collections', 'cache');

        // Tab switch
        function switchMode(mode) {
            document.querySelectorAll('.mode-section').forEach(sec => sec.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');
            document.querySelector(`.tab-btn[onclick="switchMode('${mode}')"]`).classList.add('active');
        }

        // Get config from form
        function getConfig() {
            return {
                maxsize: parseInt(document.getElementById('maxsize').value) || 128,
                ttl: document.getElementById('ttl').value ? parseInt(document.getElementById('ttl').value) : null,
                skip_args: parseInt(document.getElementById('skip_args').value) || 0,
                batch_window_ms: parseInt(document.getElementById('batch_window_ms').value) || 5,
                max_batch_size: parseInt(document.getElementById('max_batch_size').value) || 100
            };
        }

        // Configure cache (recreates with new params)
        async function configureCache() {
            const config = getConfig();
            const resp = await fetch('/configure', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(config)
            });
            const data = await resp.json();
            setResult(`Configured: ${JSON.stringify(data.config, null, 2)}`);
        }

        // Get keys for test: custom from UI if provided (for warmup etc.), else collection default
        function getKeysForTest(coll) {
            const custom = parseCustomKeys();
            if (custom) return custom;
            return coll.keys;
        }

        // Run 100 parallel requests for a collection (simulates concurrent load for herd/batch)
        // Supports custom keys; batch config; metrics ONLY from API; results show LAST test only.
        async function runCollectionTest(mode, collId) {
            const coll = collections[collId];
            const keys = getKeysForTest(coll);  // custom override e.g. for warmup keys
            const useBatch = (mode === 'cache') && document.getElementById('use_batch').checked;
            const defaultUseCache = document.getElementById('use_cache_default').checked;
            const force_miss = coll.force_miss || false;
            await configureCache();  // ensure config
            const cacheType = mode === 'cache' ? 'direct' : mode;
            const startTime = performance.now();
            // Send requests IN PARALLEL using Promise.all + fetch (demo herd/batch under concurrency)
            const requests = keys.map(key => {
                const use_cache = !force_miss && defaultUseCache;
                const body = {key, use_cache};
                if (mode === 'cache') body.use_batch = useBatch;
                return fetch(`/call/${mode}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(body)
                }).then(r => r.json());
            });
            const results = await Promise.all(requests);
            const elapsed = (performance.now() - startTime).toFixed(2);
            // Get metrics after to show hit ratio, misses (ONLY from metrics API)
            const metricsResp = await fetch(`/metrics/${cacheType}`);
            const metrics = await metricsResp.json();
            const summary = `Test: ${coll.name} | Mode: ${mode}${useBatch ? '-batch' : ''} | Keys: ${keys.length} (custom: ${!!parseCustomKeys()}) | Time: ${elapsed}ms\n` +
                           `Metrics (from API): Hits=${metrics.hits}, Misses=${metrics.misses}, Hit Rate=${(metrics.hit_rate*100).toFixed(2)}%, Size=${metrics.size}\n` +
                           `Note: All-miss OK for concurrent (DB calls minimized by herd/batch: 100ms vs 10s)`;
            setResult(summary);
            console.log('Results sample:', results.slice(0, 5));  // log full if needed
        }

        // Additional: Warmup test (uses custom keys if provided in config, else defaults)
        async function testWarmup() {
            await configureCache();
            // Override with custom or default
            let keys = parseCustomKeys();
            if (!keys) {
                keys = Array.from({length: 20}, (_, i) => `warmup-key-${i}`);
            }
            const resp = await fetch('/warmup/cache', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({keys})
            });
            const data = await resp.json();
            setResult(`Warmup: ${data.status} for ${data.keys.length} keys (custom: ${!!parseCustomKeys()}). Metrics (from API): ${JSON.stringify(data.metrics)}`);
        }

        // Test set/get/delete
        async function testSetGetDelete() {
            await configureCache();
            // set
            await fetch('/set/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key', value: 'set-value', ttl: 30})});
            // get (should hit)
            const getResp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const getData = await getResp.json();
            // delete
            await fetch('/delete/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            // get again (miss)
            const get2Resp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const get2Data = await get2Resp.json();
            const metrics = await (await fetch('/metrics/direct')).json();
            setResult(`Set/Get/Delete Test: set='set-value', get1=${getData.result}, after-delete get2=${get2Data.result}\nMetrics (from API): ${JSON.stringify(metrics)}`);
        }

        // Clear all
        async function clearAllCaches() {
            ['ttl', 'lru', 'direct'].forEach(async (t) => {
                await fetch(`/clear/${t}`, {method: 'POST'});
            });
            setResult('All caches cleared.');
        }

        // Set result (LAST test only, no append)
        function setResult(text) {
            const resDiv = document.getElementById('results');
            resDiv.textContent = '--- Last Run ---\n' + text;
            // auto scroll if needed
            resDiv.scrollTop = resDiv.scrollHeight;
        }

        // Initial config
        window.onload = () => {
            configureCache();
            setResult('UI loaded. Apply config, use custom keys, run tests (DB sleep=100ms on misses; batch/herd via timing/metrics).');
        };
    </script>
</body>
</html>
