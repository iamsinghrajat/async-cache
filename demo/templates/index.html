<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async-Cache Test UI</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f4f4f4; }
        h1, h2 { color: #333; }
        .section { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        label { display: block; margin: 10px 0; }
        input[type=number], input[type=checkbox] { margin-left: 10px; }
        button { margin: 5px; padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .results { margin-top: 10px; padding: 10px; background: #e9ecef; border-radius: 3px; white-space: pre-wrap; }
        .collection-btn { background: #28a745; }
        .collection-btn:hover { background: #218838; }
        .clear-btn { background: #dc3545; }
        .clear-btn:hover { background: #c82333; }
        .warn { color: #856404; background: #fff3cd; padding: 10px; border-radius: 3px; }
        .mode-section { display: none; }
        .mode-section.active { display: block; }
        .tabs { margin: 10px 0; }
        .tab-btn { background: #6c757d; }
        .tab-btn.active { background: #007bff; }
        /* Toggleable param groups based on mode/batch */
        .param-group { display: block; }
        .param-group.hidden { display: none; }
    </style>
</head>
<body>
    <h1>Async-Cache Test UI</h1>
    <p class="warn">Simple, functional UI to configure and test async-cache features: TTL/LRU decorators, direct AsyncCache, thundering herd protection, batch loader, metrics, warmup, set/get/delete, use_cache, skip_args etc.</p>
    
    <!-- Config Section -->
    <div class="section">
        <h2>Cache Configuration</h2>
        <p class="warn">Params adapt to interface (batch_* for direct+batch-dataloader only, skip_args/use_cache for decorators only); 100ms DB sim on misses. Keys fixed per collection (regen button); cache persists across tests (re-run uniques for hits; clear to reset).</p>
        <label>Max Size: <input id="maxsize" type="number" value="128" min="1"></label>
        <label>TTL (seconds, empty for none): <input id="ttl" type="number" value="60" min="0" placeholder="60 or empty"></label>
        <!-- skip_args: decorators (@TTL/@LRU) only -->
        <div id="skip-params" class="param-group">
            <label>Skip Args (TTL+LRU keys; e.g. skip 'self'): <input id="skip_args" type="number" value="0" min="0"></label>
        </div>
        <!-- batch params: direct + batch-dataloader enabled only -->
        <div id="batch-params" class="param-group">
            <label>Batch Window (ms): <input id="batch_window_ms" type="number" value="5" min="1"></label>
            <label>Max Batch Size: <input id="max_batch_size" type="number" value="100" min="1"></label>
        </div>
        <button onclick="configureCache()">Apply Configuration</button>
        <button onclick="regenerateKeys()">Regenerate Keys (randomize for fresh tests)</button>
        <button class="clear-btn" onclick="clearAllCaches()">Clear All Caches</button>
    </div>

    <!-- Tabs for Modes -->
    <div class="section">
        <h2>Cache Type</h2>
        <div class="tabs">
            <button class="tab-btn active" onclick="switchMode('ttl')">@AsyncTTL Decorator</button>
            <button class="tab-btn" onclick="switchMode('lru')">@AsyncLRU Decorator</button>
            <button class="tab-btn" onclick="switchMode('cache')">Direct AsyncCache</button>
        </div>
        <!-- use_cache flag: decorator-only (not for direct AsyncCache) -->
        <div id="use-cache-section">
            <label><input id="use_cache_default" type="checkbox" checked> Use Cache (force-miss=false; decorator-only param)</label>
        </div>
    </div>

    <!-- Progress bar for long tests (100 parallel requests) -->
    <div id="progress-section" class="section" style="display: none;">
        <h3>Running Test...</h3>
        <progress id="prog-bar" value="0" max="100" style="width: 100%;"></progress>
        <span id="prog-text">0% - Sending parallel requests...</span>
    </div>

    <!-- Test Collections - 5 collections for different features -->
    <div id="mode-ttl" class="section mode-section active">
        <h2>Test @AsyncTTL Decorator</h2>
        <p>Decorator-only: herd (single-loader), skip_args, TTL expiry, use_cache (force-miss flag below).</p>
        <div id="ttl-collections"></div>
    </div>

    <div id="mode-lru" class="section mode-section">
        <h2>Test @AsyncLRU Decorator</h2>
        <p>Decorator-only: herd, skip_args (now supported), LRU eviction, use_cache flag (no TTL).</p>
        <div id="lru-collections"></div>
    </div>

    <div id="mode-cache" class="section mode-section">
        <h2>Test Direct AsyncCache Class</h2>
        <p>Full features: batch dataloader (configurable), single-loader (herd prot), warmup, set/delete, metrics, etc.</p>
        <label><input id="use_batch" type="checkbox"> Use Batch Data Loader (for unique keys test; 1 DB call vs. 100)</label>
        <div id="cache-collections"></div>
        <hr>
        <h3>Additional Features</h3>
        <button onclick="testWarmup()">Warmup (preloads keys)</button>
        <button onclick="testSetGetDelete()">Test Set / Get / Delete</button>
    </div>

    <!-- Results -->
    <div class="section">
        <h2>Results & Metrics (Last Test Run Only)</h2>
        <p class="warn">Metrics ONLY from /metrics API. For all-miss cases (e.g., concurrent same/unique keys): misses=N is correct (cache semantics); herd/batch protects DB load (see timing: ~100ms vs. 10s for 100 misses). Custom keys override collections.</p>
        <div id="results" class="results">Run a test to see metrics (hit ratio, hits, misses) here...</div>
    </div>

    <script>
        // Mode-specific collections inspired by unit tests (test_lru.py/test_ttl.py/test_cache_features.py):
        // - Decorators: obj/methods/skip/refresh/clear/invalidate, eviction (LRU small size), TTL expiry sim.
        // - Direct: herd/batch/warmup (expanded).
        // Custom keys override; set config (e.g. maxsize=5 for LRU eviction, low ttl for expiry) before run.
        // Note: 100ms DB sleep; timing + metrics demo (e.g. hits=0 if uniques > maxsize).
        const modeCollections = {
            ttl: [
                {name: "1. All Same Key (Thundering Herd)", keys: Array(100).fill('ttl-same') },
                {name: "2. 100 Unique Keys (Herd + TTL expiry sim)", keys: Array.from({length: 100}, (_, i) => `ttl-unique-${i}`) },
                {name: "3. Mixed Keys (Herd mix)", keys: [...Array(50).fill('ttl-mixed'), ...Array.from({length: 50}, (_, i) => `ttl-mix-${i}`)] },
                {name: "4. Force Misses (use_cache=false)", keys: Array.from({length: 100}, (_, i) => `ttl-force-${i}`), force_miss: true },
                {name: "5. Repeat Keys (High hit ratio)", keys: Array(100).fill('ttl-repeat') },
                // TTL-inspired (test_ttl.py): vary ttl for expiry/hits
                {name: "6. Low TTL Expiry (set ttl=1s + repeat after wait)", keys: Array(10).fill('ttl-expiry') },
                {name: "7. Skip Args (set skip=1 for multi-arg)", keys: Array(50).fill('ttl-skip') }
            ],
            lru: [
                {name: "1. All Same Key (Herd)", keys: Array(100).fill('lru-same') },
                {name: "2. 100 Unique Keys (LRU maxsize test)", keys: Array.from({length: 100}, (_, i) => `lru-unique-${i}`) },
                {name: "3. Mixed Keys (Herd)", keys: [...Array(50).fill('lru-mixed'), ...Array.from({length: 50}, (_, i) => `lru-mix-${i}`)] },
                {name: "4. Force Misses (use_cache=false)", keys: Array.from({length: 100}, (_, i) => `lru-force-${i}`), force_miss: true },
                {name: "5. Repeat After Clear (Hit reset)", keys: Array(100).fill('lru-repeat') },
                // LRU-inspired (test_lru.py): eviction if uniques > maxsize, obj/skip/refresh
                {name: "6. Unique Keys > Maxsize (Eviction; set maxsize=5)", keys: Array.from({length: 20}, (_, i) => `lru-evict-${i}`) },
                {name: "7. Skip Args (set skip=1; e.g. methods)", keys: Array(50).fill('lru-skip') }
            ],
            cache: [
                {name: "1. Same Key (Herd)", keys: Array(100).fill('cache-same') },
                {name: "2. 100 Unique (Batch - 1 DB call)", keys: Array.from({length: 100}, (_, i) => `cache-unique-${i}`) },
                {name: "3. Mixed (Batch + Herd)", keys: [...Array(50).fill('cache-mixed'), ...Array.from({length: 50}, (_, i) => `cache-mix-${i}`)] },
                {name: "4. Force Misses (direct)", keys: Array.from({length: 100}, (_, i) => `cache-force-${i}`) },
                {name: "5. Repeat Keys (Hits)", keys: Array(100).fill('cache-repeat') },
                {name: "6. Batch vs Single (set batch checkbox)", keys: Array.from({length: 50}, (_, i) => `cache-batch-${i}`) },
                {name: "7. Warmup Keys (Preload)", keys: Array.from({length: 20}, (_, i) => `warm-${i}`) },
                // Direct-inspired (test_cache_features): herd/batch/warmup variants
                {name: "8. Herd Prot. (same key concurrent)", keys: Array(100).fill('cache-herd') },
                {name: "9. Batch Mixed (multi-batch_loader)", keys: Array.from({length: 150}, (_, i) => `cache-batchmix-${i}`) }  // > max_batch=100
            ]
        };

        // Keys fixed/deterministic per collection (same every run for reproducible hits on re-test).
        // Regen randomizes for fresh unique keys; no custom keys option (simplified).
        // Create/re-render buttons for collections (mode-specific)
        function createCollectionButtons(containerId, mode) {
            const container = document.getElementById(containerId);
            // clear prev buttons
            container.innerHTML = '';
            modeCollections[mode].forEach((coll, idx) => {
                const btn = document.createElement('button');
                btn.className = 'collection-btn';
                btn.textContent = coll.name;
                btn.onclick = () => runCollectionTest(mode, idx);
                container.appendChild(btn);
                container.appendChild(document.createElement('br'));
            });
        }

        // Init buttons (mode-specific)
        createCollectionButtons('ttl-collections', 'ttl');
        createCollectionButtons('lru-collections', 'lru');
        createCollectionButtons('cache-collections', 'cache');

        // Regenerate keys (randomize suffixes for fresh uniques; defaults fixed/same)
        function regenerateKeys() {
            const rand = Math.random().toString(36).substr(2, 5);  // short random
            Object.keys(modeCollections).forEach(mode => {
                modeCollections[mode].forEach(coll => {
                    if (coll.keys.length > 1 && coll.keys[0].includes('-')) {  // unique-ish
                        coll.keys = coll.keys.map((_, i) => `${mode}-key-${rand}-${i}`);
                    } else {
                        // same-key stays, or randomize single
                        const base = coll.keys[0].split('-')[0];
                        coll.keys = Array(coll.keys.length).fill(`${base}-${rand}`);
                    }
                });
            });
            // re-render buttons
            ['ttl', 'lru', 'cache'].forEach(m => createCollectionButtons(`${m}-collections`, m));
            setResult('Keys regenerated (randomized for fresh test; re-runs now unique).');
        }

        // Tab switch + dynamic params for interface:
        // - skip_args/use_cache: decorators (@TTL/@LRU) only
        // - batch_window/max_batch: direct + batch-dataloader enabled only
        // - use_cache/batch checkboxes, collections unique per mode
        // - Progress bar for tests
        function switchMode(mode) {
            document.querySelectorAll('.mode-section').forEach(sec => sec.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');
            document.querySelector(`.tab-btn[onclick="switchMode('${mode}')"]`).classList.add('active');
            // Toggle mode-specific params
            updateParamsForMode(mode);
        }

        // Update visible params based on mode (+ batch flag for direct)
        function updateParamsForMode(mode) {
            const isDecorator = (mode === 'ttl' || mode === 'lru');
            const isDirect = (mode === 'cache');
            const useBatch = isDirect && document.getElementById('use_batch').checked;
            // use_cache: decorators only
            const useCacheSec = document.getElementById('use-cache-section');
            useCacheSec.style.display = isDecorator ? 'block' : 'none';
            // skip_args: decorators only
            document.getElementById('skip-params').classList.toggle('hidden', !isDecorator);
            // batch params: direct AND batch-dataloader enabled only
            document.getElementById('batch-params').classList.toggle('hidden', !useBatch);
            // re-configure on param change for direct batch toggle
            if (isDirect) {
                document.getElementById('use_batch').onchange = () => {
                    updateParamsForMode(mode);
                    configureCache();  // re-apply for batch_window etc.
                };
            }
        }

        // Show/hide+update progress bar for running tests (100 reqs)
        function showProgress(percent, text = '') {
            const progSec = document.getElementById('progress-section');
            const bar = document.getElementById('prog-bar');
            const txt = document.getElementById('prog-text');
            progSec.style.display = 'block';
            bar.value = percent;
            txt.textContent = `${percent}% - ${text}`;
        }

        function hideProgress() {
            document.getElementById('progress-section').style.display = 'none';
        }

        // Get config from form
        function getConfig() {
            return {
                maxsize: parseInt(document.getElementById('maxsize').value) || 128,
                ttl: document.getElementById('ttl').value ? parseInt(document.getElementById('ttl').value) : null,
                skip_args: parseInt(document.getElementById('skip_args').value) || 0,
                batch_window_ms: parseInt(document.getElementById('batch_window_ms').value) || 5,
                max_batch_size: parseInt(document.getElementById('max_batch_size').value) || 100
            };
        }

        // Configure cache (recreates with new params)
        async function configureCache() {
            const config = getConfig();
            const resp = await fetch('/configure', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(config)
            });
            const data = await resp.json();
            setResult(`Configured: ${JSON.stringify(data.config, null, 2)}`);
        }

        // Keys always from collection (fixed/deterministic default; regen randomizes).
        // No custom keys option (simplified).
        function getKeysForTest(coll) {
            return coll.keys;
        }

        // Run 100 parallel requests for a collection (simulates concurrent load for herd/batch)
        // Mode-specific; NO auto-config (cache persists across runs for re-test hits; manual config/clear only).
        // Batch flag: direct-only; true= dataloader (fixed: enabled=use_batch=true).
        // metrics ONLY from API; results LAST only; progress during.
        async function runCollectionTest(mode, collId) {
            const coll = modeCollections[mode][collId];
            const keys = getKeysForTest(coll);
            const useBatch = (mode === 'cache') && document.getElementById('use_batch').checked;  // enabled=true -> batch_loader
            const defaultUseCache = document.getElementById('use_cache_default').checked;
            const force_miss = coll.force_miss || false;
            // NO await configureCache() here (prevents reset; persist for hit on re-run uniques)
            showProgress(40, `Sending ${keys.length} parallel requests...`);
            const cacheType = mode === 'cache' ? 'direct' : mode;
            const startTime = performance.now();
            // Send IN PARALLEL
            // use_cache: decorator-only; direct ignores (no force-miss param)
            // Batch: fixed enabled= batch_loader (opposite prev)
            const requests = keys.map(key => {
                const body = {key};
                if (mode !== 'cache') {
                    // decorator-only
                    const use_cache = !force_miss && defaultUseCache;
                    body.use_cache = use_cache;
                }
                if (mode === 'cache') {
                    body.use_batch = useBatch;  // true = batch (fix inversion)
                }
                return fetch(`/call/${mode}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(body)
                }).then(r => r.json());
            });
            const results = await Promise.all(requests);
            showProgress(80, 'Fetching metrics...');
            const elapsed = (performance.now() - startTime).toFixed(2);
            // Metrics from API
            const metricsResp = await fetch(`/metrics/${cacheType}`);
            const metrics = await metricsResp.json();
            const summary = `Test: ${coll.name} | Mode: ${mode}${useBatch ? '-batch' : ''} | Keys: ${keys.length} | Time: ${elapsed}ms\n` +
                           `Metrics (from API): Hits=${metrics.hits}, Misses=${metrics.misses}, Hit Rate=${(metrics.hit_rate*100).toFixed(2)}%, Size=${metrics.size}\n` +
                           `Note: First-run=misses OK; re-run same keys=hits (cache persists; clear to reset). Herd/batch: ~100ms vs 10s DB.`;
            setResult(summary);
            console.log('Results sample:', results.slice(0, 5));
            showProgress(100, 'Complete!');
            setTimeout(hideProgress, 1500);
        }

        // Warmup test (shows progress; uses collection keys; config manual for persist)
        async function testWarmup() {
            showProgress(20, 'Configuring for warmup...');
            await configureCache();  // explicit only (cache persist otherwise)
            // default keys (fixed)
            const keys = Array.from({length: 20}, (_, i) => `warmup-key-${i}`);
            showProgress(60, `Warming ${keys.length} keys...`);
            const resp = await fetch('/warmup/cache', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({keys})
            });
            const data = await resp.json();
            setResult(`Warmup: ${data.status} for ${data.keys.length} keys. Metrics (from API): ${JSON.stringify(data.metrics)}`);
            showProgress(100, 'Warmup complete!');
            setTimeout(hideProgress, 1500);
        }

        // Test set/get/delete (with progress)
        async function testSetGetDelete() {
            showProgress(30, 'Running set/get/delete...');
            await configureCache();
            // set
            await fetch('/set/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key', value: 'set-value', ttl: 30})});
            // get (should hit)
            const getResp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const getData = await getResp.json();
            // delete
            await fetch('/delete/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            // get again (miss)
            const get2Resp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const get2Data = await get2Resp.json();
            const metrics = await (await fetch('/metrics/direct')).json();
            setResult(`Set/Get/Delete Test: set='set-value', get1=${getData.result}, after-delete get2=${get2Data.result}\nMetrics (from API): ${JSON.stringify(metrics)}`);
            showProgress(100, 'Complete!');
            setTimeout(hideProgress, 1500);
        }

        // Clear all
        async function clearAllCaches() {
            showProgress(50, 'Clearing caches...');
            ['ttl', 'lru', 'direct'].forEach(async (t) => {
                await fetch(`/clear/${t}`, {method: 'POST'});
            });
            setResult('All caches cleared.');
            hideProgress();
        }

        // Set result (LAST test only, no append)
        function setResult(text) {
            const resDiv = document.getElementById('results');
            resDiv.textContent = '--- Last Run ---\n' + text;
            // auto scroll if needed
            resDiv.scrollTop = resDiv.scrollHeight;
        }

        // Initial config + param UI + defaults
        window.onload = () => {
            configureCache();
            // Default to TTL mode UI
            updateParamsForMode('ttl');
            setResult('UI loaded. Params adapt to mode (e.g., batch only for direct+batch-flag); progress bar for tests.');
        };
    </script>
</body>
</html>
