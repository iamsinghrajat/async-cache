<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async-Cache Test UI</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f4f4f4; }
        h1, h2 { color: #333; }
        .section { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        label { display: block; margin: 10px 0; }
        input[type=number], input[type=checkbox] { margin-left: 10px; }
        button { margin: 5px; padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .results { margin-top: 10px; padding: 10px; background: #e9ecef; border-radius: 3px; white-space: pre-wrap; }
        .collection-btn { background: #28a745; }
        .collection-btn:hover { background: #218838; }
        .clear-btn { background: #dc3545; }
        .clear-btn:hover { background: #c82333; }
        .warn { color: #856404; background: #fff3cd; padding: 10px; border-radius: 3px; }
        .hint { color: #0c5460; background: #d1ecf1; padding: 8px; border-radius: 3px; font-size: 0.9em; }
        .mode-section { display: none; }
        .mode-section.active { display: block; }
        .tabs { margin: 10px 0; }
        .tab-btn { background: #6c757d; }
        .tab-btn.active { background: #007bff; }
        /* Toggleable param groups based on mode/batch */
        .param-group { display: block; }
        .param-group.hidden { display: none; }
    </style>
</head>
<body>
    <h1>Async-Cache Test UI</h1>
    <p class="warn">Test async-cache features: decorators, direct cache, herd protection, batch loader, metrics, warmup.</p>
    
    <!-- Config Section -->
    <div class="section">
        <h2>Cache Configuration</h2>
        <p class="hint">Tip: Adjust maxsize and TTL to see how eviction affects hit rates.</p>
        <label>Max Size: <input id="maxsize" type="number" value="128" min="1"></label>
        <label>TTL (seconds, empty for none): <input id="ttl" type="number" value="60" min="0" placeholder="60 or empty"></label>
        <!-- skip_args: decorators (@TTL/@LRU) only -->
        <div id="skip-params" class="param-group">
            <label>Skip Args (TTL+LRU keys; e.g. skip 'self'): <input id="skip_args" type="number" value="0" min="0"></label>
        </div>
        <!-- batch params: direct + batch-dataloader enabled only; Use Batch moved here (flag controls loader) -->
        <div id="batch-params" class="param-group">
            <label>Batch Window (ms): <input id="batch_window_ms" type="number" value="5" min="1"></label>
            <label>Max Batch Size: <input id="max_batch_size" type="number" value="100" min="1"></label>
            <!-- Use Batch Data Loader: direct-only param; enabled=true -> batch_loader (dataloader), disabled=false -> single/herd -->
            <label><input id="use_batch" type="checkbox"> Use Batch Data Loader (direct only)</label>
        </div>
        <button onclick="configureCache()">Apply Configuration</button>
        <button onclick="regenerateKeys()">Regenerate Keys (randomize for fresh tests)</button>
        <button class="clear-btn" onclick="clearAllCaches()">Clear All Caches</button>
    </div>

    <!-- Tabs for Modes -->
    <div class="section">
        <h2>Cache Type</h2>
        <div class="tabs">
            <button class="tab-btn active" onclick="switchMode('ttl')">@AsyncTTL Decorator</button>
            <button class="tab-btn" onclick="switchMode('lru')">@AsyncLRU Decorator</button>
            <button class="tab-btn" onclick="switchMode('cache')">Direct AsyncCache</button>
        </div>
        <!-- use_cache flag: decorator-only (not for direct AsyncCache) -->
        <div id="use-cache-section">
            <label><input id="use_cache_default" type="checkbox" checked> Use Cache (decorator-only)</label>
        </div>
    </div>

    <!-- Progress bar for long tests (100 parallel requests) -->
    <div id="progress-section" class="section" style="display: none;">
        <h3>Running Test...</h3>
        <progress id="prog-bar" value="0" max="100" style="width: 100%;"></progress>
        <span id="prog-text">0% - Sending parallel requests...</span>
    </div>

    <!-- Test Collections - 5 collections for different features -->
    <div id="mode-ttl" class="section mode-section active">
        <h2>Test @AsyncTTL Decorator</h2>
        <p>Decorator-only: herd (single-loader), skip_args, TTL expiry, use_cache (force-miss flag below).</p>
        <div id="ttl-collections"></div>
    </div>

    <div id="mode-lru" class="section mode-section">
        <h2>Test @AsyncLRU Decorator</h2>
        <p>Decorator-only: herd, skip_args (now supported), LRU eviction, use_cache flag (no TTL).</p>
        <div id="lru-collections"></div>
    </div>

    <div id="mode-cache" class="section mode-section">
        <h2>Test Direct AsyncCache Class</h2>
        <p>Full features: batch dataloader (in config params), single-loader (herd prot), warmup, set/delete, metrics, etc.</p>
        <div id="cache-collections"></div>
        <hr>
        <h3>Additional Features</h3>
        <button onclick="testWarmup()">Warmup (preloads keys)</button>
        <button onclick="testSetGetDelete()">Test Set / Get / Delete</button>
    </div>

    <!-- Unit Test Suites -->
    <div class="section">
        <h2>Unit Test Suites</h2>
        <p class="hint">Run individual test suites to verify specific functionality.</p>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px;">
            <button class="collection-btn" onclick="runTestSuite('core')" style="background: #17a2b8;">Core Cache Tests</button>
            <button class="collection-btn" onclick="runTestSuite('features')" style="background: #17a2b8;">Features Tests</button>
            <button class="collection-btn" onclick="runTestSuite('concurrency')" style="background: #17a2b8;">Concurrency Tests</button>
            <button class="collection-btn" onclick="runTestSuite('edge_cases')" style="background: #17a2b8;">Edge Cases Tests</button>
            <button class="collection-btn" onclick="runTestSuite('lru')" style="background: #17a2b8;">LRU Decorator Tests</button>
            <button class="collection-btn" onclick="runTestSuite('ttl')" style="background: #17a2b8;">TTL Decorator Tests</button>
        </div>
        
        <button class="collection-btn" onclick="runTestSuite('all')" style="background: #6f42c1; width: 100%; font-weight: bold;">Run All Test Suites</button>
        <div id="suite-results" class="results" style="margin-top: 10px; display: none;"></div>
    </div>

    <!-- Results -->
    <div class="section">
        <h2>Results & Metrics</h2>
        <p class="hint">Test results and cache metrics appear here.</p>
        <div id="results" class="results">Run a test to see results...</div>
    </div>

    <script>
        // Simplified to exactly 3 key combinations per interface: 100 same, 100 unique, 50 same + 50 different.
        // Button names clean (no notes/suggestions like "Herd"; e.g., just "50 Same + 50 Different Keys").
        // Keys fixed/same by default; regen randomizes; batch flag in params (enabled=true uses batch_loader).
        // Cache persists for re-runs (hits on uniques).
        // Note: For unique keys, we store base keys and shuffle order on each run to avoid LRU eviction cascade.
        const modeCollections = {
            ttl: [
                {name: "1. 100 Same Key", baseKeys: Array(100).fill('ttl-same') },
                {name: "2. 100 Unique Keys", baseKeys: Array.from({length: 100}, (_, i) => `ttl-unique-key-${i}`) },  // stable/fixed values
                {name: "3. 50 Same + 50 Different Keys", baseKeys: [...Array(50).fill('ttl-same'), ...Array.from({length: 50}, (_, i) => `ttl-diff-${i}`)] }
            ],
            lru: [
                {name: "1. 100 Same Key", baseKeys: Array(100).fill('lru-same') },
                {name: "2. 100 Unique Keys", baseKeys: Array.from({length: 100}, (_, i) => `lru-unique-key-${i}`) },  // stable/fixed values
                {name: "3. 50 Same + 50 Different Keys", baseKeys: [...Array(50).fill('lru-same'), ...Array.from({length: 50}, (_, i) => `lru-diff-${i}`)] }
            ],
            cache: [
                {name: "1. 100 Same Key", baseKeys: Array(100).fill('cache-same') },
                {name: "2. 100 Unique Keys", baseKeys: Array.from({length: 100}, (_, i) => `cache-unique-key-${i}`) },  // stable/fixed values
                {name: "3. 50 Same + 50 Different Keys", baseKeys: [...Array(50).fill('cache-same'), ...Array.from({length: 50}, (_, i) => `cache-diff-${i}`)] }
            ]
        };

        // Fisher-Yates shuffle to randomize key order while keeping same key values
        function shuffleArray(array) {
            const shuffled = [...array];  // copy to avoid mutating original
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Keys fixed/deterministic per collection (same every run for reproducible hits on re-test).
        // Regen randomizes for fresh unique keys; no custom keys option (simplified).
        // Create/re-render buttons for collections (mode-specific)
        function createCollectionButtons(containerId, mode) {
            const container = document.getElementById(containerId);
            // clear prev buttons
            container.innerHTML = '';
            modeCollections[mode].forEach((coll, idx) => {
                const btn = document.createElement('button');
                btn.className = 'collection-btn';
                btn.textContent = coll.name;
                btn.onclick = () => runCollectionTest(mode, idx);
                container.appendChild(btn);
                container.appendChild(document.createElement('br'));
            });
        }

        // Init buttons (mode-specific)
        createCollectionButtons('ttl-collections', 'ttl');
        createCollectionButtons('lru-collections', 'lru');
        createCollectionButtons('cache-collections', 'cache');

        // Regenerate keys (randomize suffixes for fresh uniques; defaults fixed/same)
        function regenerateKeys() {
            const rand = Math.random().toString(36).substr(2, 5);  // short random
            Object.keys(modeCollections).forEach(mode => {
                modeCollections[mode].forEach(coll => {
                    if (coll.baseKeys.length > 1 && coll.baseKeys[0].includes('-')) {  // unique-ish
                        coll.baseKeys = coll.baseKeys.map((_, i) => `${mode}-key-${rand}-${i}`);
                    } else {
                        // same-key stays, or randomize single
                        const base = coll.baseKeys[0].split('-')[0];
                        coll.baseKeys = Array(coll.baseKeys.length).fill(`${base}-${rand}`);
                    }
                });
            });
            // re-render buttons
            ['ttl', 'lru', 'cache'].forEach(m => createCollectionButtons(`${m}-collections`, m));
            setResult('Keys regenerated (randomized for fresh test; re-runs now unique).');
        }

        // Tab switch + dynamic params for interface:
        // - skip_args/use_cache: decorators (@TTL/@LRU) only
        // - batch_window/max_batch: direct + batch-dataloader enabled only
        // - use_cache/batch checkboxes, collections unique per mode
        // - Progress bar for tests
        function switchMode(mode) {
            document.querySelectorAll('.mode-section').forEach(sec => sec.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');
            document.querySelector(`.tab-btn[onclick="switchMode('${mode}')"]`).classList.add('active');
            // Toggle mode-specific params
            updateParamsForMode(mode);
        }

        // Update visible params based on mode (+ batch flag for direct)
        function updateParamsForMode(mode) {
            const isDecorator = (mode === 'ttl' || mode === 'lru');
            const isDirect = (mode === 'cache');
            const useBatch = isDirect && document.getElementById('use_batch').checked;
            // use_cache: decorators only
            const useCacheSec = document.getElementById('use-cache-section');
            useCacheSec.style.display = isDecorator ? 'block' : 'none';
            // skip_args: decorators only
            document.getElementById('skip-params').classList.toggle('hidden', !isDecorator);
            // batch params: direct AND batch-dataloader enabled only
            document.getElementById('batch-params').classList.toggle('hidden', !useBatch);
            // re-configure on param change for direct batch toggle
            if (isDirect) {
                document.getElementById('use_batch').onchange = () => {
                    updateParamsForMode(mode);
                    configureCache();  // re-apply for batch_window etc.
                };
            }
        }

        // Show/hide+update progress bar for running tests (100 reqs)
        function showProgress(percent, text = '') {
            const progSec = document.getElementById('progress-section');
            const bar = document.getElementById('prog-bar');
            const txt = document.getElementById('prog-text');
            progSec.style.display = 'block';
            bar.value = percent;
            txt.textContent = `${percent}% - ${text}`;
        }

        function hideProgress() {
            document.getElementById('progress-section').style.display = 'none';
        }

        // Get config from form
        function getConfig() {
            return {
                maxsize: parseInt(document.getElementById('maxsize').value) || 128,
                ttl: document.getElementById('ttl').value ? parseInt(document.getElementById('ttl').value) : null,
                skip_args: parseInt(document.getElementById('skip_args').value) || 0,
                batch_window_ms: parseInt(document.getElementById('batch_window_ms').value) || 5,
                max_batch_size: parseInt(document.getElementById('max_batch_size').value) || 100
            };
        }

        // Configure cache (recreates with new params)
        async function configureCache() {
            const config = getConfig();
            const resp = await fetch('/configure', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(config)
            });
            const data = await resp.json();
            setResult(`Configured: ${JSON.stringify(data.config, null, 2)}`);
        }

        // Keys always from collection (fixed/deterministic default; regen randomizes).
        // Shuffle order on each call to avoid LRU eviction cascade when cache < unique keys.
        // No custom keys option (simplified).
        function getKeysForTest(coll) {
            // For unique keys collections, shuffle order to randomize access pattern
            // This prevents LRU eviction cascade when cache size < number of unique keys
            const allSame = coll.baseKeys.every(k => k === coll.baseKeys[0]);
            if (allSame) {
                // All same key - no need to shuffle
                return coll.baseKeys;
            }
            // Shuffle to randomize access order while keeping same key values
            return shuffleArray(coll.baseKeys);
        }

        // Run 100 parallel requests for a collection (simulates concurrent load for herd/batch)
        // Mode-specific; NO auto-config (cache persists across runs for re-test hits; manual config/clear only).
        // Batch flag: direct-only; true= dataloader (fixed: enabled=use_batch=true).
        // metrics ONLY from API; results LAST only; progress during.
        async function runCollectionTest(mode, collId) {
            const coll = modeCollections[mode][collId];
            const keys = getKeysForTest(coll);
            const useBatch = (mode === 'cache') && document.getElementById('use_batch').checked;  // enabled=true -> batch_loader
            const defaultUseCache = document.getElementById('use_cache_default').checked;
            const force_miss = coll.force_miss || false;
            // NO await configureCache() here (prevents reset; persist for hit on re-run uniques)
            showProgress(40, `Sending ${keys.length} parallel requests...`);
            const cacheType = mode === 'cache' ? 'direct' : mode;
            // Pre-test metrics (from API only) for per-run delta/ratio
            const preResp = await fetch(`/metrics/${cacheType}`);
            const pre = await preResp.json();
            const startTime = performance.now();
            // Send IN PARALLEL
            // use_cache: decorator-only; direct ignores (no force-miss param)
            // Batch: fixed enabled= batch_loader
            const requests = keys.map(key => {
                const body = {key};
                if (mode !== 'cache') {
                    // decorator-only
                    const use_cache = !force_miss && defaultUseCache;
                    body.use_cache = use_cache;
                }
                if (mode === 'cache') {
                    body.use_batch = useBatch;  // true = batch
                }
                return fetch(`/call/${mode}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(body)
                }).then(r => r.json());
            });
            const results = await Promise.all(requests);
            showProgress(80, 'Fetching metrics...');
            const elapsed = (performance.now() - startTime).toFixed(2);
            // Post-test metrics from API
            const postResp = await fetch(`/metrics/${cacheType}`);
            const post = await postResp.json();
            // Delta for this test (accurate ratio e.g. ~90/100=90% for maxsize=90 + 100 unique re-run; accum totals otherwise)
            // Guard for NaN/negative (ensures UI rate high even if edge race)
            const dHits = Math.max(0, post.hits - pre.hits);
            const dMisses = Math.max(0, post.misses - pre.misses);
            const dTotal = dHits + dMisses;
            const dRate = dTotal > 0 ? (dHits / dTotal * 100).toFixed(2) : 0;
            const summary = `Test: ${coll.name} | Mode: ${mode}${useBatch ? '-batch' : ''} | Keys: ${keys.length} | Time: ${elapsed}ms\n` +
                           `This run (from API delta): Hits=${dHits}, Misses=${dMisses}, Hit Rate=${dRate}%, Size=${post.size}\n` +
                           `Note: Key order shuffled each run to avoid LRU eviction cascade. Expect ~maxsize hits on re-run.`;
            setResult(summary);
            // Debug log for keys/rate (helps identify any key mismatch/race in UI vs unit)
            console.log('Pre metrics:', pre, 'Post:', post, 'Delta rate:', dRate, 'Keys sample:', keys.slice(0, 3));
            showProgress(100, 'Complete!');
            setTimeout(hideProgress, 1500);
        }

        // Warmup test (shows progress; uses collection keys; config manual for persist)
        async function testWarmup() {
            showProgress(20, 'Configuring for warmup...');
            await configureCache();  // explicit only (cache persist otherwise)
            // default keys (fixed)
            const keys = Array.from({length: 20}, (_, i) => `warmup-key-${i}`);
            showProgress(60, `Warming ${keys.length} keys...`);
            const resp = await fetch('/warmup/cache', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({keys})
            });
            const data = await resp.json();
            setResult(`Warmup: ${data.status} for ${data.keys.length} keys. Metrics (from API): ${JSON.stringify(data.metrics)}`);
            showProgress(100, 'Warmup complete!');
            setTimeout(hideProgress, 1500);
        }

        // Test set/get/delete (with progress)
        async function testSetGetDelete() {
            showProgress(30, 'Running set/get/delete...');
            await configureCache();
            // set
            await fetch('/set/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key', value: 'set-value', ttl: 30})});
            // get (should hit)
            const getResp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const getData = await getResp.json();
            // delete
            await fetch('/delete/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            // get again (miss)
            const get2Resp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const get2Data = await get2Resp.json();
            const metrics = await (await fetch('/metrics/direct')).json();
            setResult(`Set/Get/Delete Test: set='set-value', get1=${getData.result}, after-delete get2=${get2Data.result}\nMetrics (from API): ${JSON.stringify(metrics)}`);
            showProgress(100, 'Complete!');
            setTimeout(hideProgress, 1500);
        }

        // Clear all
        async function clearAllCaches() {
            showProgress(50, 'Clearing caches...');
            ['ttl', 'lru', 'direct'].forEach(async (t) => {
                await fetch(`/clear/${t}`, {method: 'POST'});
            });
            setResult('All caches cleared.');
            hideProgress();
        }

        // Run concurrency test suite
        async function runConcurrencyTests() {
            const resultsDiv = document.getElementById('concurrency-results');
            resultsDiv.style.display = 'block';
            resultsDiv.textContent = 'Running concurrency tests...';
            
            showProgress(50, 'Running concurrency tests...');
            
            try {
                const resp = await fetch('/test/concurrency', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({})
                });
                const data = await resp.json();
                
                let summary = `Concurrency Test Results\n`;
                summary += `========================\n`;
                summary += `Tests Run: ${data.tests_run}\n`;
                summary += `Failures: ${data.failures}\n`;
                summary += `Errors: ${data.errors}\n`;
                summary += `Success: ${data.success ? '✓ PASSED' : '✗ FAILED'}\n\n`;
                
                if (data.output) {
                    summary += `Test Output:\n${data.output}\n`;
                }
                
                if (data.failure_details && data.failure_details.length > 0) {
                    summary += `\nFailures:\n`;
                    data.failure_details.forEach(f => {
                        summary += `- ${f.test}: ${f.error.substring(0, 200)}...\n`;
                    });
                }
                
                if (data.error_details && data.error_details.length > 0) {
                    summary += `\nErrors:\n`;
                    data.error_details.forEach(e => {
                        summary += `- ${e.test}: ${e.error.substring(0, 200)}...\n`;
                    });
                }
                
                resultsDiv.textContent = summary;
                setResult(`Concurrency tests: ${data.success ? 'PASSED' : 'FAILED'} (${data.tests_run} tests, ${data.failures} failures, ${data.errors} errors)`);
            } catch (e) {
                resultsDiv.textContent = `Error running tests: ${e.message}`;
                setResult(`Concurrency tests failed with error: ${e.message}`);
            }
            
            showProgress(100, 'Complete!');
            setTimeout(hideProgress, 1500);
        }

        // Run all unit tests
        async function runAllUnitTests() {
            const resultsDiv = document.getElementById('all-tests-results');
            resultsDiv.style.display = 'block';
            resultsDiv.textContent = 'Running all unit tests...';
            
            showProgress(50, 'Running all unit tests...');
            
            try {
                const resp = await fetch('/test/all', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({})
                });
                const data = await resp.json();
                
                let summary = `Full Unit Test Results\n`;
                summary += `========================\n`;
                summary += `Tests Run: ${data.tests_run}\n`;
                summary += `Failures: ${data.failures}\n`;
                summary += `Errors: ${data.errors}\n`;
                summary += `Success: ${data.success ? '✓ PASSED' : '✗ FAILED'}\n\n`;
                
                if (data.output) {
                    summary += `Test Output:\n${data.output}\n`;
                }
                
                if (data.failure_details && data.failure_details.length > 0) {
                    summary += `\nFailures:\n`;
                    data.failure_details.forEach(f => {
                        summary += `- ${f.test}: ${f.error.substring(0, 200)}...\n`;
                    });
                }
                
                if (data.error_details && data.error_details.length > 0) {
                    summary += `\nErrors:\n`;
                    data.error_details.forEach(e => {
                        summary += `- ${e.test}: ${e.error.substring(0, 200)}...\n`;
                    });
                }
                
                resultsDiv.textContent = summary;
                setResult(`All unit tests: ${data.success ? 'PASSED' : 'FAILED'} (${data.tests_run} tests, ${data.failures} failures, ${data.errors} errors)`);
            } catch (e) {
                resultsDiv.textContent = `Error running tests: ${e.message}`;
                setResult(`Unit tests failed with error: ${e.message}`);
            }
            
            showProgress(100, 'Complete!');
            setTimeout(hideProgress, 1500);
        }

        // Run specific test suite
        async function runTestSuite(suiteName) {
            const resultsDiv = document.getElementById('suite-results');
            resultsDiv.style.display = 'block';
            resultsDiv.textContent = `Running ${suiteName} test suite...`;
            
            showProgress(50, `Running ${suiteName} tests...`);
            
            try {
                const resp = await fetch(`/test/suite/${suiteName}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({})
                });
                const data = await resp.json();
                
                if (data.error) {
                    resultsDiv.textContent = `Error: ${data.error}`;
                    setResult(`Test suite error: ${data.error}`);
                    return;
                }
                
                let summary = `${suiteName.toUpperCase()} Test Results\n`;
                summary += `========================\n`;
                summary += `Tests Run: ${data.tests_run}\n`;
                summary += `Failures: ${data.failures}\n`;
                summary += `Errors: ${data.errors}\n`;
                summary += `Success: ${data.success ? '✓ PASSED' : '✗ FAILED'}\n\n`;
                
                if (data.output) {
                    summary += `Test Output:\n${data.output}\n`;
                }
                
                if (data.failure_details && data.failure_details.length > 0) {
                    summary += `\nFailures:\n`;
                    data.failure_details.forEach(f => {
                        summary += `- ${f.test}: ${f.error.substring(0, 200)}...\n`;
                    });
                }
                
                if (data.error_details && data.error_details.length > 0) {
                    summary += `\nErrors:\n`;
                    data.error_details.forEach(e => {
                        summary += `- ${e.test}: ${e.error.substring(0, 200)}...\n`;
                    });
                }
                
                resultsDiv.textContent = summary;
                setResult(`${suiteName} tests: ${data.success ? 'PASSED' : 'FAILED'} (${data.tests_run} tests)`);
            } catch (e) {
                resultsDiv.textContent = `Error running tests: ${e.message}`;
                setResult(`Test suite failed with error: ${e.message}`);
            }
            
            showProgress(100, 'Complete!');
            setTimeout(hideProgress, 1500);
        }

        // Set result (LAST test only, no append)
        function setResult(text) {
            const resDiv = document.getElementById('results');
            resDiv.textContent = '--- Last Run ---\n' + text;
            // auto scroll if needed
            resDiv.scrollTop = resDiv.scrollHeight;
        }

        // Initial config + param UI + defaults
        window.onload = () => {
            configureCache();
            // Default to TTL mode UI
            updateParamsForMode('ttl');
            setResult('UI loaded. Params adapt to mode (e.g., batch only for direct+batch-flag); progress bar for tests.');
        };
    </script>
</body>
</html>
