<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async-Cache Test UI</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f4f4f4; }
        h1, h2 { color: #333; }
        .section { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        label { display: block; margin: 10px 0; }
        input[type=number], input[type=checkbox] { margin-left: 10px; }
        button { margin: 5px; padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .results { margin-top: 10px; padding: 10px; background: #e9ecef; border-radius: 3px; white-space: pre-wrap; }
        .collection-btn { background: #28a745; }
        .collection-btn:hover { background: #218838; }
        .clear-btn { background: #dc3545; }
        .clear-btn:hover { background: #c82333; }
        .warn { color: #856404; background: #fff3cd; padding: 10px; border-radius: 3px; }
        .mode-section { display: none; }
        .mode-section.active { display: block; }
        .tabs { margin: 10px 0; }
        .tab-btn { background: #6c757d; }
        .tab-btn.active { background: #007bff; }
    </style>
</head>
<body>
    <h1>Async-Cache Test UI</h1>
    <p class="warn">Simple, functional UI to configure and test async-cache features: TTL/LRU decorators, direct AsyncCache, thundering herd protection, batch loader, metrics, warmup, set/get/delete, use_cache, skip_args etc.</p>
    
    <!-- Config Section -->
    <div class="section">
        <h2>Cache Configuration</h2>
        <label>Max Size: <input id="maxsize" type="number" value="128" min="1"></label>
        <label>TTL (seconds, empty for none): <input id="ttl" type="number" value="60" min="0" placeholder="60 or empty"></label>
        <label>Skip Args (for TTL key): <input id="skip_args" type="number" value="0" min="0"></label>
        <label>Batch Window (ms): <input id="batch_window_ms" type="number" value="5" min="1"></label>
        <label>Max Batch Size: <input id="max_batch_size" type="number" value="100" min="1"></label>
        <label><input id="use_cache_default" type="checkbox" checked> Default Use Cache</label>
        <button onclick="configureCache()">Apply Configuration</button>
        <button class="clear-btn" onclick="clearAllCaches()">Clear All Caches</button>
    </div>

    <!-- Tabs for Modes -->
    <div class="section">
        <h2>Cache Type</h2>
        <div class="tabs">
            <button class="tab-btn active" onclick="switchMode('ttl')">@AsyncTTL Decorator</button>
            <button class="tab-btn" onclick="switchMode('lru')">@AsyncLRU Decorator</button>
            <button class="tab-btn" onclick="switchMode('cache')">Direct AsyncCache</button>
        </div>
    </div>

    <!-- Test Collections - 5 collections for different features -->
    <div id="mode-ttl" class="section mode-section active">
        <h2>Test @AsyncTTL Decorator</h2>
        <p>Tests herd protection (same key), batch not direct here (single loader), skip_args, TTL expiry, use_cache=false.</p>
        <div id="ttl-collections"></div>
    </div>

    <div id="mode-lru" class="section mode-section">
        <h2>Test @AsyncLRU Decorator</h2>
        <p>Similar to TTL but no expiry/TTL. Good for hit/miss ratios.</p>
        <div id="lru-collections"></div>
    </div>

    <div id="mode-cache" class="section mode-section">
        <h2>Test Direct AsyncCache Class</h2>
        <p>Full features: batch_loader (for unique keys), single_loader (herd), warmup, set, delete, metrics.</p>
        <label><input id="use_batch" type="checkbox"> Use Batch Loader (for batch tests)</label>
        <div id="cache-collections"></div>
        <hr>
        <h3>Additional Features</h3>
        <button onclick="testWarmup()">Warmup (preloads keys)</button>
        <button onclick="testSetGetDelete()">Test Set / Get / Delete</button>
    </div>

    <!-- Results -->
    <div class="section">
        <h2>Results & Metrics</h2>
        <div id="results" class="results">Run a test to see metrics (hit ratio, hits, misses) here...</div>
    </div>

    <script>
        // 5 collections of 100 requests with diff key combos to test features
        const collections = {
            1: {name: "1. All Same Key (Tests Thundering Herd Protection - expect ~1 miss)", keys: Array(100).fill('same-key') },
            2: {name: "2. 100 Unique Keys (Tests Batch Data Loader - expect all misses in 1 batch)", keys: Array.from({length: 100}, (_, i) => `unique-key-${i}`) },
            3: {name: "3. Mixed Keys (50 same + 50 unique - mix herd + batch)", keys: [...Array(50).fill('mixed-key'), ...Array.from({length: 50}, (_, i) => `mix-${i}`)] },
            4: {name: "4. Force Misses (use_cache=false x100 - bypass cache)", keys: Array.from({length: 100}, (_, i) => `force-${i}`), force_miss: true },
            5: {name: "5. Repeat Keys After Load (Expect high hit ratio)", keys: Array(100).fill('repeat-key') }  // run after other to see hits
        };

        // Create buttons for each collection per mode
        function createCollectionButtons(containerId, mode) {
            const container = document.getElementById(containerId);
            Object.keys(collections).forEach(id => {
                const coll = collections[id];
                const btn = document.createElement('button');
                btn.className = 'collection-btn';
                btn.textContent = coll.name;
                btn.onclick = () => runCollectionTest(mode, parseInt(id));
                container.appendChild(btn);
                container.appendChild(document.createElement('br'));
            });
        }

        // Init buttons
        createCollectionButtons('ttl-collections', 'ttl');
        createCollectionButtons('lru-collections', 'lru');
        createCollectionButtons('cache-collections', 'cache');

        // Tab switch
        function switchMode(mode) {
            document.querySelectorAll('.mode-section').forEach(sec => sec.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');
            document.querySelector(`.tab-btn[onclick="switchMode('${mode}')"]`).classList.add('active');
        }

        // Get config from form
        function getConfig() {
            return {
                maxsize: parseInt(document.getElementById('maxsize').value) || 128,
                ttl: document.getElementById('ttl').value ? parseInt(document.getElementById('ttl').value) : null,
                skip_args: parseInt(document.getElementById('skip_args').value) || 0,
                batch_window_ms: parseInt(document.getElementById('batch_window_ms').value) || 5,
                max_batch_size: parseInt(document.getElementById('max_batch_size').value) || 100
            };
        }

        // Configure cache (recreates with new params)
        async function configureCache() {
            const config = getConfig();
            const resp = await fetch('/configure', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(config)
            });
            const data = await resp.json();
            appendResult(`Configured: ${JSON.stringify(data.config, null, 2)}`);
        }

        // Run 100 parallel requests for a collection (simulates concurrent load for herd/batch)
        async function runCollectionTest(mode, collId) {
            const coll = collections[collId];
            const useBatch = (mode === 'cache') && document.getElementById('use_batch').checked;
            const defaultUseCache = document.getElementById('use_cache_default').checked;
            const force_miss = coll.force_miss || false;
            await configureCache();  // ensure config
            const cacheType = mode === 'cache' ? 'direct' : mode;
            const startTime = performance.now();
            // Send 100 requests IN PARALLEL using Promise.all + fetch
            const requests = coll.keys.map(key => {
                const use_cache = !force_miss && defaultUseCache;
                const body = {key, use_cache};
                if (mode === 'cache') body.use_batch = useBatch;
                return fetch(`/call/${mode}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(body)
                }).then(r => r.json());
            });
            const results = await Promise.all(requests);
            const elapsed = (performance.now() - startTime).toFixed(2);
            // Get metrics after to show hit ratio, misses
            const metricsResp = await fetch(`/metrics/${cacheType}`);
            const metrics = await metricsResp.json();
            const summary = `Test: ${coll.name} | Mode: ${mode}${useBatch ? '-batch' : ''} | Time: ${elapsed}ms\n` +
                           `Metrics: Hits=${metrics.hits}, Misses=${metrics.misses}, Hit Rate=${(metrics.hit_rate*100).toFixed(2)}%, Size=${metrics.size}`;
            appendResult(summary);
            console.log('Results sample:', results.slice(0, 5));  // log full if needed
        }

        // Additional: Warmup test
        async function testWarmup() {
            await configureCache();
            const keys = Array.from({length: 20}, (_, i) => `warmup-key-${i}`);
            const resp = await fetch('/warmup/cache', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({keys})
            });
            const data = await resp.json();
            appendResult(`Warmup: ${data.status} for ${data.keys.length} keys. Metrics: ${JSON.stringify(data.metrics)}`);
        }

        // Test set/get/delete
        async function testSetGetDelete() {
            await configureCache();
            // set
            await fetch('/set/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key', value: 'set-value', ttl: 30})});
            // get (should hit)
            const getResp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const getData = await getResp.json();
            // delete
            await fetch('/delete/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            // get again (miss)
            const get2Resp = await fetch('/call/cache', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({key: 'test-key'})});
            const get2Data = await get2Resp.json();
            const metrics = await (await fetch('/metrics/direct')).json();
            appendResult(`Set/Get/Delete Test: set='set-value', get1=${getData.result}, after-delete get2=${get2Data.result}\nMetrics: ${JSON.stringify(metrics)}`);
        }

        // Clear all
        async function clearAllCaches() {
            ['ttl', 'lru', 'direct'].forEach(async (t) => {
                await fetch(`/clear/${t}`, {method: 'POST'});
            });
            appendResult('All caches cleared.');
        }

        // Append to results
        function appendResult(text) {
            const resDiv = document.getElementById('results');
            resDiv.textContent += '\n---\n' + text;
            resDiv.scrollTop = resDiv.scrollHeight;  // auto scroll
        }

        // Initial config
        window.onload = () => {
            configureCache();
            appendResult('UI loaded. Apply config and run tests to see caching in action!');
        };
    </script>
</body>
</html>
